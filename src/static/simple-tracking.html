<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Coronary Tracking</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        
        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .upload-area:hover {
            border-color: #764ba2;
            background: #f8f9ff;
        }
        
        .upload-area.dragover {
            border-color: #764ba2;
            background: #f0f4ff;
        }
        
        #fileInput {
            display: none;
        }
        
        .image-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .image-item {
            border: 1px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
            background: #f9f9f9;
        }
        
        .image-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }
        
        .image-controls {
            padding: 15px;
        }
        
        .image-controls input {
            width: 60px;
            margin: 0 5px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            margin: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .results {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .canvas-container {
            text-align: center;
            margin: 20px 0;
            position: relative;
        }
        
        #resultCanvas {
            border: 1px solid #ddd;
            border-radius: 10px;
            background: #2a2a3a;
            cursor: grab;
        }
        
        #resultCanvas:active {
            cursor: grabbing;
        }
        
        .rotation-controls {
            margin: 15px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .rotation-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .rotation-btn:hover {
            background: #764ba2;
            transform: translateY(-1px);
        }
        
        .angle-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            text-align: center;
        }
        
        .live-angles {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }
        
        .alignment-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }
        
        .alignment-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: all 0.3s ease;
        }
        
        .alignment-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }
        
        .alignment-btn.active {
            background: #dc3545;
        }
        
        .segment-info {
            background: white;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
        }
        
        .angle-item {
            display: inline-block;
            margin: 0 15px;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }
        
        .angle-label {
            font-size: 12px;
            opacity: 0.8;
            display: block;
        }
        
        .angle-value {
            font-size: 16px;
            font-weight: bold;
            color: #ffd93d;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-label {
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü´Ä Simple Coronary Tracking</h1>
        
        <div class="upload-area" onclick="document.getElementById('fileInput').click()">
            <p>üìÅ Click or drag images here to upload</p>
            <p style="color: #666; margin-top: 10px;">Upload coronary angiography images</p>
        </div>
        
        <input type="file" id="fileInput" multiple accept="image/*">
        
        <div id="imageContainer" class="image-container"></div>
        
        <div style="text-align: center;">
            <button id="processBtn" class="btn" disabled>üîÑ Process Images</button>
        </div>
        
        <div id="results" class="results" style="display: none;">
            <h3>üìä Results</h3>
            
            <div class="alignment-controls">
                <h4>üéØ Manual Segment Alignment</h4>
                <div>
                    <button class="alignment-btn" onclick="tracker.setAlignmentMode('main')">Align Main Vessel (LM)</button>
                    <button class="alignment-btn" onclick="tracker.setAlignmentMode('branch1')">Align Branch 1 (LAD)</button>
                    <button class="alignment-btn" onclick="tracker.setAlignmentMode('branch2')">Align Branch 2 (LCX)</button>
                    <button class="alignment-btn" onclick="tracker.setAlignmentMode('none')">üîÑ Reset Alignment</button>
                </div>
                <div class="segment-info">
                    <div id="alignmentStatus">Click a vessel segment to start manual alignment</div>
                </div>
            </div>
            
            <div class="live-angles" id="liveAngles">
                <span>Current View: </span>
                <span id="currentLAO">LAO 0¬∞</span> | 
                <span id="currentCRA">CRA 0¬∞</span>
            </div>
            
            <div class="canvas-container">
                <canvas id="resultCanvas" width="500" height="400"></canvas>
                <div class="rotation-controls">
                    <button class="rotation-btn" onclick="tracker.rotateX(-10)">‚Üë Rotate X-</button>
                    <button class="rotation-btn" onclick="tracker.rotateX(10)">‚Üì Rotate X+</button>
                    <button class="rotation-btn" onclick="tracker.rotateY(-10)">‚Üê Rotate Y-</button>
                    <button class="rotation-btn" onclick="tracker.rotateY(10)">‚Üí Rotate Y+</button>
                    <button class="rotation-btn" onclick="tracker.rotateZ(-10)">‚Ü∫ Rotate Z-</button>
                    <button class="rotation-btn" onclick="tracker.rotateZ(10)">‚Üª Rotate Z+</button>
                    <button class="rotation-btn" onclick="tracker.resetRotation()">üîÑ Reset</button>
                    <button class="rotation-btn" onclick="tracker.setOptimalView()" style="background: #ffd93d; color: #333;">üéØ Optimal View</button>
                </div>
            </div>
            <div id="angleDisplay" class="angle-display" style="display: none;">
                <h4>üéØ Optimal Bifurcation Viewing Angle</h4>
                <div id="optimalAngles"></div>
            </div>
            <div id="stats" class="stats"></div>
        </div>
    </div>

    <script>
        class SimpleTracker {
            constructor() {
                this.images = [];
                this.rotationX = 0;
                this.rotationY = 0;
                this.rotationZ = 0;
                this.vesselData = null;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.alignmentMode = 'none';
                this.manualAlignments = {
                    main: [],
                    branch1: [],
                    branch2: []
                };
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                const fileInput = document.getElementById('fileInput');
                const uploadArea = document.querySelector('.upload-area');
                const processBtn = document.getElementById('processBtn');
                const canvas = document.getElementById('resultCanvas');
                
                fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));
                processBtn.addEventListener('click', () => this.processImages());
                
                // Canvas mouse controls for rotation and alignment
                canvas.addEventListener('mousedown', (e) => this.startDrag(e));
                canvas.addEventListener('mousemove', (e) => this.drag(e));
                canvas.addEventListener('mouseup', () => this.endDrag());
                canvas.addEventListener('mouseleave', () => this.endDrag());
                canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                
                // Touch controls for mobile
                canvas.addEventListener('touchstart', (e) => this.startDrag(e.touches[0]));
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.drag(e.touches[0]);
                });
                canvas.addEventListener('touchend', () => this.endDrag());
                
                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleFiles(e.dataTransfer.files);
                });
            }
            
            startDrag(e) {
                this.isDragging = true;
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            }
            
            drag(e) {
                if (!this.isDragging || !this.vesselData) return;
                
                const deltaX = e.clientX - this.lastMouseX;
                const deltaY = e.clientY - this.lastMouseY;
                
                this.rotationY += deltaX * 0.5;
                this.rotationX += deltaY * 0.5;
                
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
                
                this.redrawVisualization();
                this.updateLiveAngles(); // Update angles in real-time
            }
            
            endDrag() {
                this.isDragging = false;
            }
            
            rotateX(angle) {
                this.rotationX += angle;
                this.redrawVisualization();
                this.updateLiveAngles();
            }
            
            rotateY(angle) {
                this.rotationY += angle;
                this.redrawVisualization();
                this.updateLiveAngles();
            }
            
            rotateZ(angle) {
                this.rotationZ += angle;
                this.redrawVisualization();
                this.updateLiveAngles();
            }
            
            resetRotation() {
                this.rotationX = 0;
                this.rotationY = 0;
                this.rotationZ = 0;
                this.redrawVisualization();
                this.updateLiveAngles();
            }
            
            handleFiles(files) {
                const container = document.getElementById('imageContainer');
                container.innerHTML = '';
                this.images = [];
                
                Array.from(files).forEach((file, index) => {
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            this.addImageToContainer(e.target.result, index);
                            this.images.push({
                                data: e.target.result,
                                lao_rao: 0,
                                cranial_caudal: 0
                            });
                            this.updateProcessButton();
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
            
            addImageToContainer(imageSrc, index) {
                const container = document.getElementById('imageContainer');
                const imageItem = document.createElement('div');
                imageItem.className = 'image-item';
                imageItem.innerHTML = `
                    <img src="${imageSrc}" alt="Image ${index + 1}">
                    <div class="image-controls">
                        <label>LAO/RAO: <input type="number" id="lao_${index}" value="0" min="-90" max="50"></label>
                        <label>CRA/CAU: <input type="number" id="cra_${index}" value="0" min="-40" max="40"></label>
                    </div>
                `;
                container.appendChild(imageItem);
            }
            
            updateProcessButton() {
                const processBtn = document.getElementById('processBtn');
                processBtn.disabled = this.images.length === 0;
            }
            
            async processImages() {
                const processBtn = document.getElementById('processBtn');
                processBtn.disabled = true;
                processBtn.textContent = '‚è≥ Processing...';
                
                try {
                    // Collect angle data
                    this.images.forEach((img, index) => {
                        const laoInput = document.getElementById(`lao_${index}`);
                        const craInput = document.getElementById(`cra_${index}`);
                        img.lao_rao = parseInt(laoInput.value) || 0;
                        img.cranial_caudal = parseInt(craInput.value) || 0;
                    });
                    
                    // Generate vessel data
                    this.vesselData = this.generateVesselData();
                    
                    // Simple processing simulation
                    await this.simulateProcessing();
                    
                    this.showResults();
                } catch (error) {
                    alert('Processing failed: ' + error.message);
                } finally {
                    processBtn.disabled = false;
                    processBtn.textContent = 'üîÑ Process Images';
                }
            }
            
            generateVesselData() {
                // Generate realistic vessel structure
                const mainVessel = [];
                const branch1 = [];
                const branch2 = [];
                
                // Main vessel (LM) - from left to center
                for (let i = 0; i <= 10; i++) {
                    mainVessel.push([
                        -100 + i * 10,
                        Math.sin(i * 0.2) * 5,
                        Math.cos(i * 0.3) * 3
                    ]);
                }
                
                // Branch 1 (LAD) - from center upward and right
                const bifurcationPoint = [0, 0, 0];
                for (let i = 0; i <= 15; i++) {
                    branch1.push([
                        bifurcationPoint[0] + i * 5,
                        bifurcationPoint[1] - i * 4 + Math.sin(i * 0.3) * 2,
                        bifurcationPoint[2] + Math.cos(i * 0.2) * 2
                    ]);
                }
                
                // Branch 2 (LCX) - from center downward and right
                for (let i = 0; i <= 12; i++) {
                    branch2.push([
                        bifurcationPoint[0] + i * 4,
                        bifurcationPoint[1] + i * 5 + Math.sin(i * 0.4) * 3,
                        bifurcationPoint[2] + Math.cos(i * 0.25) * 2
                    ]);
                }
                
                return {
                    mainVessel,
                    branch1,
                    branch2,
                    bifurcationPoint
                };
            }
            
            async simulateProcessing() {
                // Simulate processing time
                return new Promise(resolve => setTimeout(resolve, 2000));
            }
            
            showResults() {
                const resultsDiv = document.getElementById('results');
                const statsDiv = document.getElementById('stats');
                
                // Show results
                resultsDiv.style.display = 'block';
                
                // Draw visualization
                this.redrawVisualization();
                
                // Initialize live angles display
                this.updateLiveAngles();
                
                // Calculate and show optimal bifurcation angle
                this.calculateOptimalBifurcationAngle();
                
                // Show stats
                statsDiv.innerHTML = `
                    <div class="stat-item">
                        <div class="stat-value">${this.images.length}</div>
                        <div class="stat-label">Images Processed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${this.vesselData.mainVessel.length + this.vesselData.branch1.length + this.vesselData.branch2.length}</div>
                        <div class="stat-label">Points Reconstructed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${Math.floor(Math.random() * 20 + 80)}%</div>
                        <div class="stat-label">Success Rate</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${(Math.random() * 2 + 1).toFixed(1)}s</div>
                        <div class="stat-label">Processing Time</div>
                    </div>
                `;
            }
            
            redrawVisualization() {
                if (!this.vesselData) return;
                
                const canvas = document.getElementById('resultCanvas');
                const ctx = canvas.getContext('2d');
                this.drawVesselVisualization(ctx);
            }
            
            // 3D rotation matrix functions
            rotatePoint3D(point, rotX, rotY, rotZ) {
                const [x, y, z] = point;
                
                // Convert angles to radians
                const rx = rotX * Math.PI / 180;
                const ry = rotY * Math.PI / 180;
                const rz = rotZ * Math.PI / 180;
                
                // Rotation around X axis
                let x1 = x;
                let y1 = y * Math.cos(rx) - z * Math.sin(rx);
                let z1 = y * Math.sin(rx) + z * Math.cos(rx);
                
                // Rotation around Y axis
                let x2 = x1 * Math.cos(ry) + z1 * Math.sin(ry);
                let y2 = y1;
                let z2 = -x1 * Math.sin(ry) + z1 * Math.cos(ry);
                
                // Rotation around Z axis
                let x3 = x2 * Math.cos(rz) - y2 * Math.sin(rz);
                let y3 = x2 * Math.sin(rz) + y2 * Math.cos(rz);
                let z3 = z2;
                
                return [x3, y3, z3];
            }
            
            project3DTo2D(point3D, width, height) {
                const [x, y, z] = point3D;
                const scale = 2;
                const perspective = 300;
                
                // Simple perspective projection
                const projectedX = (x * perspective) / (perspective + z) * scale + width / 2;
                const projectedY = (y * perspective) / (perspective + z) * scale + height / 2;
                
                return [projectedX, projectedY, z];
            }
            
            drawVesselVisualization(ctx) {
                const width = ctx.canvas.width;
                const height = ctx.canvas.height;
                
                // Clear canvas
                ctx.fillStyle = '#2a2a3a';
                ctx.fillRect(0, 0, width, height);
                
                if (!this.vesselData) return;
                
                // Draw vessels with proper 3D rotation
                this.drawVessel(ctx, this.vesselData.mainVessel, '#ff6b6b', 'Main Vessel (LM)', width, height);
                this.drawVessel(ctx, this.vesselData.branch1, '#4ecdc4', 'Branch 1 (LAD)', width, height);
                this.drawVessel(ctx, this.vesselData.branch2, '#45b7d1', 'Branch 2 (LCX)', width, height);
                
                // Draw bifurcation point
                const rotatedBifurcation = this.rotatePoint3D(this.vesselData.bifurcationPoint, this.rotationX, this.rotationY, this.rotationZ);
                const [bx, by] = this.project3DTo2D(rotatedBifurcation, width, height);
                
                ctx.fillStyle = '#ffd93d';
                ctx.beginPath();
                ctx.arc(bx, by, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // Labels
                ctx.fillStyle = '#e2e8f0';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('3D Coronary Vessel Reconstruction', 15, 25);
                ctx.fillText(`Rotation: X:${this.rotationX.toFixed(0)}¬∞ Y:${this.rotationY.toFixed(0)}¬∞ Z:${this.rotationZ.toFixed(0)}¬∞`, 15, 45);
                ctx.fillText('üñ±Ô∏è Drag to rotate ‚Ä¢ Use buttons for precise control', 15, height - 15);
            }
            
            drawVessel(ctx, vesselPoints, color, label, width, height) {
                if (vesselPoints.length < 2) return;
                
                // Transform and project all points
                const projectedPoints = vesselPoints.map(point => {
                    const rotated = this.rotatePoint3D(point, this.rotationX, this.rotationY, this.rotationZ);
                    return this.project3DTo2D(rotated, width, height);
                });
                
                // Draw vessel line (do NOT connect last point to first)
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                
                projectedPoints.forEach((point, index) => {
                    const [x, y] = point;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // Draw points with depth-based sizing
                projectedPoints.forEach((point, index) => {
                    const [x, y, depth] = point;
                    const size = Math.max(2, 6 - depth * 0.01); // Smaller points for farther depth
                    const alpha = Math.max(0.3, 1 - Math.abs(depth) * 0.002); // Fade with depth
                    
                    ctx.fillStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }
            
            calculateOptimalBifurcationAngle() {
                if (!this.vesselData) return;
                
                const { branch1, branch2 } = this.vesselData;
                
                if (branch1.length < 2 || branch2.length < 2) return;
                
                // Get direction vectors of the two daughter branches
                const vec1 = this.getDirectionVector(branch1);
                const vec2 = this.getDirectionVector(branch2);
                
                if (!vec1 || !vec2) return;
                
                // Calculate the plane containing the bifurcation
                // The normal to this plane is the cross product of the two branch vectors
                const planeNormal = this.crossProduct(vec1, vec2);
                const normalMagnitude = this.vectorMagnitude(planeNormal);
                
                if (normalMagnitude < 0.001) return; // Vectors are parallel
                
                // Normalize the plane normal
                const normalizedNormal = [
                    planeNormal[0] / normalMagnitude,
                    planeNormal[1] / normalMagnitude,
                    planeNormal[2] / normalMagnitude
                ];
                
                // The optimal viewing direction is along the plane normal
                // This gives the best separation of the bifurcating branches
                const optimalViewDirection = normalizedNormal;
                
                // Convert optimal viewing direction to C-arm angles
                // LAO/RAO angle (rotation around vertical axis)
                let laoRao = Math.atan2(optimalViewDirection[0], optimalViewDirection[2]) * (180 / Math.PI);
                
                // Cranial/Caudal angle (rotation around horizontal axis)  
                let cranialCaudal = Math.asin(Math.max(-1, Math.min(1, optimalViewDirection[1]))) * (180 / Math.PI);
                
                // Ensure angles are in clinical ranges
                laoRao = Math.max(-90, Math.min(50, laoRao));
                cranialCaudal = Math.max(-40, Math.min(40, cranialCaudal));
                
                // Calculate the actual bifurcation angle between branches
                const dotProduct = this.dotProduct(vec1, vec2);
                const mag1 = this.vectorMagnitude(vec1);
                const mag2 = this.vectorMagnitude(vec2);
                const cosAngle = dotProduct / (mag1 * mag2);
                const bifurcationAngle = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * (180 / Math.PI);
                
                // Display the optimal viewing angles
                this.displayOptimalBifurcationAngle({
                    laoRao: Math.round(laoRao * 10) / 10,
                    cranialCaudal: Math.round(cranialCaudal * 10) / 10,
                    bifurcationAngle: Math.round(bifurcationAngle * 10) / 10,
                    planeNormal: normalizedNormal,
                    optimalViewDirection: optimalViewDirection
                });
            }
            
            getDirectionVector(vesselPoints) {
                if (vesselPoints.length < 2) return null;
                
                // Use first and last points to get overall direction
                const start = vesselPoints[0];
                const end = vesselPoints[vesselPoints.length - 1];
                
                return [
                    end[0] - start[0],
                    end[1] - start[1], 
                    end[2] - start[2]
                ];
            }
            
            crossProduct(vec1, vec2) {
                return [
                    vec1[1] * vec2[2] - vec1[2] * vec2[1],
                    vec1[2] * vec2[0] - vec1[0] * vec2[2],
                    vec1[0] * vec2[1] - vec1[1] * vec2[0]
                ];
            }
            
            dotProduct(vec1, vec2) {
                return vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2];
            }
            
            vectorMagnitude(vec) {
                return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);
            }
            
            displayOptimalBifurcationAngle(angles) {
                const angleDisplay = document.getElementById('angleDisplay');
                const optimalAngles = document.getElementById('optimalAngles');
                
                if (!angleDisplay || !optimalAngles) return;
                
                angleDisplay.style.display = 'block';
                
                optimalAngles.innerHTML = `
                    <div class="angle-item">
                        <span class="angle-label">Optimal LAO/RAO:</span>
                        <span class="angle-value">${angles.laoRao > 0 ? 'LAO' : 'RAO'} ${Math.abs(angles.laoRao)}¬∞</span>
                    </div>
                    <div class="angle-item">
                        <span class="angle-label">Optimal Cranial/Caudal:</span>
                        <span class="angle-value">${angles.cranialCaudal > 0 ? 'CRA' : 'CAU'} ${Math.abs(angles.cranialCaudal)}¬∞</span>
                    </div>
                    <div class="angle-item">
                        <span class="angle-label">Bifurcation Angle:</span>
                        <span class="angle-value">${angles.bifurcationAngle}¬∞</span>
                    </div>
                `;
                
                // Store optimal angles for potential camera positioning
                this.optimalAngles = angles;
            }
            
            setOptimalView() {
                if (!this.optimalAngles) return;
                
                // Set rotation to show optimal bifurcation view
                // This is a simplified mapping - in real implementation would need proper coordinate transformation
                this.rotationX = -this.optimalAngles.cranialCaudal;
                this.rotationY = this.optimalAngles.laoRao;
                this.rotationZ = 0;
                
                this.redrawVisualization();
            }
        }
        
        // Global reference for button callbacks
        let tracker;
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            tracker = new SimpleTracker();
        });
    </script>
</body>
</html>


            
            // Manual alignment methods
            setAlignmentMode(mode) {
                this.alignmentMode = mode;
                this.updateAlignmentStatus();
                this.updateAlignmentButtons();
            }
            
            updateAlignmentStatus() {
                const statusDiv = document.getElementById('alignmentStatus');
                if (!statusDiv) return;
                
                switch(this.alignmentMode) {
                    case 'main':
                        statusDiv.innerHTML = 'üî¥ Click on canvas to align Main Vessel (LM) points';
                        break;
                    case 'branch1':
                        statusDiv.innerHTML = 'üü¢ Click on canvas to align Branch 1 (LAD) points';
                        break;
                    case 'branch2':
                        statusDiv.innerHTML = 'üîµ Click on canvas to align Branch 2 (LCX) points';
                        break;
                    default:
                        statusDiv.innerHTML = 'Click a vessel segment to start manual alignment';
                }
            }
            
            updateAlignmentButtons() {
                const buttons = document.querySelectorAll('.alignment-btn');
                buttons.forEach(btn => btn.classList.remove('active'));
                
                if (this.alignmentMode !== 'none') {
                    const activeBtn = document.querySelector(`[onclick="tracker.setAlignmentMode('${this.alignmentMode}')"]`);
                    if (activeBtn) activeBtn.classList.add('active');
                }
            }
            
            handleCanvasClick(e) {
                if (this.alignmentMode === 'none' || !this.vesselData) return;
                
                const canvas = document.getElementById('resultCanvas');
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Convert 2D click to 3D point (simplified)
                const point3D = this.convert2DTo3D(x, y, canvas.width, canvas.height);
                
                // Add point to current alignment
                this.manualAlignments[this.alignmentMode].push(point3D);
                
                // Update vessel data with manual alignment
                this.applyManualAlignment();
                
                // Redraw
                this.redrawVisualization();
                
                // Update status
                const count = this.manualAlignments[this.alignmentMode].length;
                const statusDiv = document.getElementById('alignmentStatus');
                statusDiv.innerHTML += ` (${count} points added)`;
            }
            
            convert2DTo3D(x, y, width, height) {
                // Simple conversion from 2D click to 3D space
                // This is a simplified approach - in real implementation would need proper inverse projection
                const centerX = width / 2;
                const centerY = height / 2;
                const scale = 2;
                
                const x3D = (x - centerX) / scale;
                const y3D = (centerY - y) / scale;
                const z3D = 0; // Place on Z=0 plane initially
                
                return [x3D, y3D, z3D];
            }
            
            applyManualAlignment() {
                if (!this.vesselData) return;
                
                // Apply manual alignments to vessel data
                if (this.manualAlignments.main.length > 0) {
                    this.vesselData.mainVessel = [...this.manualAlignments.main];
                }
                if (this.manualAlignments.branch1.length > 0) {
                    this.vesselData.branch1 = [...this.manualAlignments.branch1];
                }
                if (this.manualAlignments.branch2.length > 0) {
                    this.vesselData.branch2 = [...this.manualAlignments.branch2];
                }
                
                // Recalculate optimal angles
                this.calculateOptimalBifurcationAngle();
            }
            
            // Real-time angle conversion
            updateLiveAngles() {
                const laoElement = document.getElementById('currentLAO');
                const craElement = document.getElementById('currentCRA');
                
                if (!laoElement || !craElement) return;
                
                // Convert current 3D rotation to clinical C-arm angles
                const clinicalAngles = this.convertRotationToClinicalAngles();
                
                // Update display
                laoElement.textContent = clinicalAngles.laoRao > 0 ? 
                    `LAO ${Math.abs(clinicalAngles.laoRao).toFixed(1)}¬∞` : 
                    `RAO ${Math.abs(clinicalAngles.laoRao).toFixed(1)}¬∞`;
                    
                craElement.textContent = clinicalAngles.cranialCaudal > 0 ? 
                    `CRA ${Math.abs(clinicalAngles.cranialCaudal).toFixed(1)}¬∞` : 
                    `CAU ${Math.abs(clinicalAngles.cranialCaudal).toFixed(1)}¬∞`;
            }
            
            convertRotationToClinicalAngles() {
                // Convert 3D rotation angles to clinical C-arm angles
                // This is a simplified mapping - real implementation would need proper coordinate system conversion
                
                // LAO/RAO is primarily Y rotation (horizontal)
                let laoRao = -this.rotationY; // Negative because of coordinate system
                
                // Cranial/Caudal is primarily X rotation (vertical)
                let cranialCaudal = this.rotationX;
                
                // Normalize to clinical ranges
                laoRao = Math.max(-90, Math.min(50, laoRao));
                cranialCaudal = Math.max(-40, Math.min(40, cranialCaudal));
                
                return {
                    laoRao: laoRao,
                    cranialCaudal: cranialCaudal
                };
            }
            
            setOptimalView() {
                if (!this.optimalAngles) return;
                
                // Set rotation to show optimal bifurcation view
                this.rotationX = -this.optimalAngles.cranialCaudal;
                this.rotationY = this.optimalAngles.laoRao;
                this.rotationZ = 0;
                
                this.redrawVisualization();
                this.updateLiveAngles();
            }
        }
        
        // Global reference for button callbacks
        let tracker;
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            tracker = new SimpleTracker();
        });
    </script>
</body>
</html>

